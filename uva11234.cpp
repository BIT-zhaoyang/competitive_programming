#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0), cout.precision(15);
#define UNVISITED -1
#define BIGINT 1 << 28
using namespace std;

typedef long long int64;
typedef pair<int, int> ii;

/* Thoughts about this problem:
    This problem is a tree problem. Since I know this, I can guess out the solution easily. Just build a tree and observe the desired output, then it's easy to find out the correct solution is to output the BFS in reverse order. But why this solution works confused me for a long time. Here are my explanation.

    The first observation is that, the postfix expression forms a full binary tree, and the postfix is a post traverse of the tree. In fact, a recursion can be converted to an iterative fashion using stack. After replacing the stack with a queue, the only difference seems to be that, the computed result/operand will be put at the end instead of at the front. What result will this difference cause? For example, if the given sequence is xyP, which stands for xPy in infix expression, using stack to do the operation, we can get the correct result. But using queue to do the operation, we get yPx, which has reversed operands order. Thus, my first conjection to solve this problem is: we do DFS using a queue in reverse order, namely, visit the right child first. To verify the idea, I still adopted the concept of recursion, namely, if there is a subtree, I just treat it as a simple node. Thus, I created three test examples:
    (Remember the operations are:  a := pop(); b := pop(); push(b O a); Notice the reverse order of a and b while doing computation.)
        P
      a   b
    stack visit: abP    ->      aPb
    queue visit: baP    ->      aPb (correct)

        P
      a   Q
         b  c
    stack visit: abcQP  ->      aP(bQc)
    queue visit: cbQaP  ->      aP(bQc) (correct)

        P
      Q   a
    b   c
    stack visit: bcQaP  ->      (bQc)Pa
    queue visit: acbQP  ->      (cQa)Pb (wrong)

    Notice that the third test example is wrong, which is expected since I know the correct solution is reversly output BFS. But where the error is. What is the difference between the first example and the third example? More generally, for a tree like this
            P
        Q       W
     a     b c     d
    If I do reverse DFS, the output will be
    dcbaWQP -> aP(bQ(cWd)) which is different with ((aQb)P(cWd)).

    I noticed that the operation order totally changed, and realized that it's the brackets make the tree to have different structure. When using stack, the DFS works in a divide conquer manner. It visit the left subtree, keep the result generated by the left subtree in stack and visit the right subtree. While visiting the right subtree, no matter how deep the recursion goes, it never touch the stored result generated by left subtree, since newly generated results will cover over it. In another word, the result from left subtree is isolated from the other operations.

    However, if we use a queue, the results are used in a rotate manner. The result from the left subtree will be touched when the visit on the right subtree goes further, previous result will comes front, even though it was at the back when inserted. In another word, the result from left subtree is NOT isolated from the other operations in the right subtree.

    So, to prevent mis-usage of previously generated result, when visit a node, all nodes having a deeper layer than it should be already visited, which is a BFS. Intuitively, BFS executes like: it finds all deepest in the infix expression and compute them. For example, in ((aXb)Yc)((aXb)Yc), the two (aXb) will both be computed first. In contrast, using DFS, the whole first ((aXb)Yc) will be executed first.

    Knowing that using a queue leads to a BFS and we need to visit the right child first, we can get that the correct solution is reversly output BFS.
*/
struct Node{
    char ch;
    Node *left, *right;
    Node(char ch){
        this->ch = ch;
        left = right = NULL;
    }

    ~Node(){
        if(left != NULL){
            delete left;
            left = NULL;
        }
        if(right != NULL){
            delete right;
            right = NULL;
        }
    }
};

Node* build_tree(string &line, int &idx){
    char ch = line[idx++];
    Node *node = new Node(ch);
    if(ch >= 'A' && ch <= 'Z'){
        node->right = build_tree(line, idx);
        node->left = build_tree(line, idx);
    }
    return node;
}

int main(){ _
    int tc; cin >> tc;
    while(tc--){
        string line;
        cin >> line;
        reverse(line.begin(), line.end());

        int idx = 0;
        Node *root = build_tree(line, idx);

        queue<Node*> Q;
        stack<char> sc;
        Q.push(root);
        while(!Q.empty()){
            Node *p = Q.front();    Q.pop();
            sc.push(p->ch);
            Node *left = p->left, *right = p->right;
            if(left) Q.push(left);
            if(right) Q.push(right);
        }
        while(sc.size()){
            cout << sc.top();
            sc.pop();
        }
        cout << endl;
        delete root;
    }
    return 0;
}
