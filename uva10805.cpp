#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0), cout.precision(15);
#define UNVISITED -1
#define POSINF 1 << 28
#define NEGINF -1 << 28
using namespace std;

typedef long long int64;
typedef pair<int, int> ii;

// ============================= Solution 1 ================================
/* Reference:
    1. http://bit.ly/2fWYHSy   problem C    or search play with trees in case the link deosn't work
    2. http://bit.ly/2fF8BVK
    3. http://bit.ly/2fYi77m
    This vertex is O(V^3), since for each edge E, we add a virtual vertex and find the best position on this edge takes O(V) time. This solution is a more general solution compared to Solution 2 we will describe later. This solution can also work on weighted graphs.
*/
// int n, m;
// vector< vector<int> > AdjList, dist, permute;   // permute: sort permutation
// vector<int> currDist;
//
// bool mysort(int a, int b){
//     return currDist[a] > currDist[b];
// }
//
// void bfs(int root){
//     queue<int> Q;
//     dist[root][root] = 0;
//     Q.push(root);
//
//     while(!Q.empty()){
//         int u = Q.front();  Q.pop();
//         for(int i = 0; i < AdjList[u].size(); ++i){
//             int v = AdjList[u][i];
//             if(dist[root][v] == UNVISITED){
//                 dist[root][v] = dist[root][u] + 1;
//                 Q.push(v);
//             }
//         }
//     }
//
//     for(int i = 0; i < dist[root].size(); ++i){
//         permute[root][i] = i;
//         currDist[i] = dist[root][i];
//     }
//     // after computing dist[root][], get the sort permutation
//     sort(permute[root].begin(), permute[root].end(), mysort);
// }
//
// int main(){ _
//     int TC; cin >> TC;
//     for(int tc = 1; tc <= TC; ++tc){
//         cout << "Case #" << tc << ":" << endl;
//         cin >> n >> m;
//         AdjList.assign(n, vector<int> (0));
//         dist.assign(n, vector<int> (n, UNVISITED));
//         permute.assign(n, vector<int> (n, UNVISITED));
//         currDist.assign(n, UNVISITED);
//
//         for(int i = 0; i < m; ++i){
//             int u, v;   cin >> u >> v;
//             AdjList[u].push_back(v);
//             AdjList[v].push_back(u);
//         }
//
//         // Compute all pairwise distance using BFS, since it's unweighted
//         for(int i = 0; i < n; ++i)  bfs(i);
//
//         // Process vertual vertex lying on each edge
//         int diameter = POSINF;
//         for(int u = 0; u < n; ++u){
//             diameter = min(diameter, dist[u][permute[u][0]] * 2);
//             // In theory, we should only check edge (u, v) exists in the given graph
//             // But it doesn't harm to check every possible edge (u, v) even it doesn't exists
//             // Since this virtual edge has a shortest path connect them. Let's say it is u - w -v
//             // Then, the answer we get on checking edge (u, w) and (w, v) will be no worse than the
//             // answer we get while checking the virtual edge (u, v)
//             // Of course, we can only check real existing edge (u, v) if we want
//             for(int v = u + 1; v < n; ++v){
//                 diameter = min(diameter, dist[v][permute[v][0]] * 2);
//                 int last = permute[u][0];
//                 for(int i = 1; i < n; ++i){
//                     int curr = permute[u][i];
//                     if(dist[v][curr] < dist[v][last]) continue;
//                     diameter = min(diameter, dist[u][curr] + dist[v][last] + dist[u][v]);
//                     last = curr;
//                 }
//             }
//         }
//
//         cout << diameter << endl << endl;
//     }
//     return 0;
// }

// ============================= Solution 2 ================================
/* Reference:
    http://bit.ly/2fYi77m
    After you understand why Shortest Path Tree generated by BFS doesn't work(bcause the visit order is not determined and may lead to different result. But the shortest distance part is correct), you will understand why this soluiton works.

    Since the central vertex is definetly at the middle of the longest path, and while we compute the shortest distance, the distance has already been multiplied by 2, thus the computed radius equals the diameter of the tree, in numerical sense.

    Notice that, in finding farthest point part, we only consider vertices(both virtual and real) to real vertices. This helps cicumvent the problem we metioned in the first paragraph.

    This method is O(V^4) since we add a virtual vertex for each edge, thus the total number of vertices becomes O(V + E). Each BFS takes O(V + E). In total, it's O(V^4).
*/
int n, m;
vector< vector<int> > AdjList;

int bfs(int root){
    vector<int> dist(n + m, UNVISITED); dist[root] = 0;
    queue<int> Q;   Q.push(root);

    while(!Q.empty()){
        int u = Q.front();  Q.pop();
        for(int i = 0; i < AdjList[u].size(); ++i){
            int v = AdjList[u][i];
            if(dist[v] == UNVISITED){
                dist[v] = dist[u] + 1;
                Q.push(v);
            }
        }
    }

    int farthest = 0;
    for(int i = 0; i < n; ++i)  farthest = max(farthest, dist[i]);

    return farthest;
}

int main(){ _
    int TC; cin >> TC;
    for(int tc = 1; tc <= TC; ++tc){
        cout << "Case #" << tc << ":" << endl;
        cin >> n >> m;
        AdjList.assign(n + m, vector<int> (0));
        for(int i = 0, j = n; i < m; ++i, ++j){
            int u, v;   cin >> u >> v;
            AdjList[u].push_back(j);
            AdjList[j].push_back(u);
            AdjList[v].push_back(j);
            AdjList[j].push_back(v);
        }

        int diameter = POSINF;
        for(int i = 0; i < n + m; ++i)
            diameter = min(diameter, bfs(i));

        cout << diameter << endl << endl;
    }
}
